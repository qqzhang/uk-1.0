/*
 * lib.c
 *
 * Copyright (C) 2006  Insigma Co., Ltd
 *
 * This software has been developed while working on the Linux Unified Kernel
 * project (http://www.longene.org) in the Insigma Research Institute,  
 * which is a subdivision of Insigma Co., Ltd (http://www.insigma.com.cn).
 * 
 * The project is sponsored by Insigma Co., Ltd.
 *
 * The authors can be reached at linux@insigma.com.cn.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of  the GNU General  Public License as published by the
 * Free Software Foundation; either version 2 of the  License, or (at your
 * option) any later version.
 *
 * Revision History:
 *   Dec 2008 - Created.
 */

#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/syscalls.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/spinlock.h>
#include <linux/cred.h> /* for getuid() */
#include <linux/file.h>
#include <linux/fdtable.h>
#include <linux/pid.h>
#include <linux/net.h>
#include <linux/tcp.h>
#include <net/sock.h>
#include <net/tcp.h>
#include <asm/uaccess.h>
#include <asm-generic/ioctls.h> /* for tcgetattr */

#undef PARITY_NONE

#include "ntstatus.h"
#define WIN32_NO_STATUS
#include "winternl.h"
#include "stdio.h"
#include "stdlib.h"
#include "assert.h"
#include "errno.h"
#include "klog.h"
#include "thread.h"
#include "sched.h"
#include "termios.h"
#include "wine/unicode.h"
#include "sys/sysctl.h"
#include "sys/time.h"
#include "lib.h"

#define PREPARE_KERNEL_CALL \
{ \
    mm_segment_t oldfs; \
    oldfs = get_fs(); \
    set_fs(KERNEL_DS);

#define END_KERNEL_CALL	\
    set_fs(oldfs); \
}

#define MAXSIZE_ALLOC (128*1024) //128K

#define stdin   ((FILE*)0)

char *optarg = NULL;
int optind, opterr, optopt;
int getopt_long(int argc, char * const argv[],
        const char *optstring,
        //      const struct option *longopts,
        const void *longopts,
        int *longindex)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

time_t start_time;

static int dummy_errno=0;

#define SYSCALL_RETURN(ret) \
    do{ \
        if(IS_ERR_VALUE(ret)) { \
            klog(0," errno=%d \n",(int)ret); \
            current_thread ? (current_thread->unix_errno=-ret) : (dummy_errno=-ret); \
            ret = -1; \
        } \
        return ret; \
    }while(0)

int *_errno(void)
{
    return current_thread ? &(current_thread->unix_errno) : &dummy_errno;
}

void _assert (const char *assertion, const char *file, unsigned int line)
{
    printk ("Detected: %s %u:Assertion %s failed!\n", file, line, assertion);
    dump_stack();
}

/*get_kernel_proc_address*/
typedef unsigned long (*FUNCTION_POINTER)(const char *name);
static FUNCTION_POINTER kallsyms_lookup_name_ptr = NULL;
unsigned long read_kallsyms(char *symbol_name);
void *syscall_array[UK_NR_SYSCALLS] = {0};

#define MAX_BUF_LEN 100
#define PROC_HOME    "/proc/kallsyms"

int kgetline(struct file *file, char *buf)
{
    int i = 0;
    char c = 0;
    int nbytes = 0;
    char temp[MAX_BUF_LEN] = {0};

    for(i=0; i<MAX_BUF_LEN && c!='\n'; i++)
    {
        nbytes = file->f_op->read(file, &c, 1,&file->f_pos);
        if(nbytes==0)
            break;
        temp[i] = c;
        buf[i] = c;
    }
    //printk("Line(%d): %s", i, temp);
    return i;
}

unsigned long read_kallsyms(char *symbol_name)
{
    mm_segment_t old_fs;
    ssize_t bytes;
    struct file *file = NULL;
    char *p;
    int i = 0, len;
    unsigned long addr = 0;

    char line[MAX_BUF_LEN] = {0};
    char new_symbol_name[MAX_BUF_LEN] = "T ";
    strcat(new_symbol_name, symbol_name);
    //	printk("new_symbol_name: %s\n", new_symbol_name);
    len = strlen(new_symbol_name);

    file = filp_open(PROC_HOME,O_RDONLY,0);
    if (!file)

        return -1;

    if (!file->f_op->read)
        return -1;

    old_fs = get_fs();
    set_fs(get_ds());

    for(;;)
    {
        bytes = kgetline(file,line);
        if(bytes==0)
            break;
        if (( p = strstr(line, new_symbol_name)) != NULL)
        {
/*
NOTES: ' ' & '\t'
c0123456 T sys_read
e0654321 T cdrom_open    [cdrom]
*/
            if( (*(p+len) != '\n') && (*(p+len) != '\t') )
                continue;

            //			printk("line:%s\n", line);

            for(i=0; i<MAX_BUF_LEN; i++)
            {
                if(line[i] == ' ')
                    break;
            }
            line[i] = '\0';

            addr = simple_strtoul(line,NULL,16);

            //			printk("addr(%s): %x\n", symbol_name, addr);

            break;
        }
        memset(line, 0, MAX_BUF_LEN);
    }

    filp_close(file,NULL);

    set_fs(old_fs);
    return addr;
}

void get_kallsyms_lookup_name(void)
{
    int i;
    kallsyms_lookup_name_ptr = (FUNCTION_POINTER)read_kallsyms("kallsyms_lookup_name");

    if (!kallsyms_lookup_name_ptr) 
    {
        printk("Couldn't find kallsyms_lookup_name()\n");
    } 
    else 
    {
        printk("UK:kallsyms_lookup_name=%08x \n",(unsigned int)kallsyms_lookup_name_ptr);
    }

    for(i=0; i<UK_NR_SYSCALLS; i++)
    {
        syscall_array[i] = (void*)kallsyms_lookup_name_ptr(syscall_names[i]);
        if (syscall_array[i] == NULL)
            klog(0,"get %s addr failed \n",syscall_names[i]);
    }
}

void* get_kernel_proc_address(char *funcname)
{
    void * addr = (void*)kallsyms_lookup_name_ptr(funcname); 
    if (!addr) 
    {
        printk("%s : %s=NULL\n",__func__,funcname);
        dump_stack();
    }

    return addr;
}


#ifdef MEM_LEAK_CHECK
static LIST_HEAD(mem_leak_list);

#define NAME_LEN 32
struct mem_leak
{
    struct list_head entry;
    void *p;
    size_t size;
    int line;
    char filename[16];
    char func[NAME_LEN];
};

char *strrchr(const char *s, int c)
{
    const char *p = s + strlen(s);
    do
    {
        if (*p == (char)c)
            return (char *)p;
    } while (--p >= s);

    return NULL;
}

void add_to_list(gfp_t flags, void *ptr, size_t size, const char *func, const char *filename, int line)
{
    char *p;
    struct mem_leak *mem_leak = kzalloc(sizeof(struct mem_leak), flags);
    if(!mem_leak)
    {
        klog(0," alloc mem_leak error \n");
        return;
    }

    mem_leak->p = ptr;
    mem_leak->line = line;
    mem_leak->size = size;
    strncpy(mem_leak->func, func, NAME_LEN);

    p = strrchr(filename, '/');
    strcpy(mem_leak->filename,p+1);

    list_add(&mem_leak->entry, &mem_leak_list);
}

void remove_from_list(void *ptr)
{
    struct mem_leak *mem_leak = NULL;
    struct list_head *pos = NULL, *pos1 = NULL;

    LIST_FOR_EACH_SAFE(pos, pos1, &mem_leak_list)
    {
        mem_leak = (struct mem_leak *)pos;

        if(mem_leak->p == ptr)
        {
            list_del(&mem_leak->entry);
            kfree(mem_leak);
        }
    }
}

void print_mem_list(void)
{
    unsigned long long total=0;
    struct mem_leak *mem_leak = NULL;
    struct list_head *pos = NULL;
    struct list_head *pos1 = NULL;

    LIST_FOR_EACH_SAFE(pos, pos1, &mem_leak_list)
    {
        mem_leak = (struct mem_leak *)pos;

        printk("ptr %08x size %08x %s[%d]:%s\n",\
                mem_leak->p,mem_leak->size,mem_leak->filename,mem_leak->line,mem_leak->func);

        total += mem_leak->size;
        list_del(&mem_leak->entry);
        kfree((void*)mem_leak);
    }
    printk("total %08lx\n",total);
}

void *_malloc_atomic(size_t size, const char *func, const char *filename, int line)
{
    void	*addr;

    if (size > MAXSIZE_ALLOC || !(addr = kmalloc(size, GFP_ATOMIC)))
    {
        klog(0,"kmalloc size %x err, too large\n", size);
        set_error(STATUS_NO_MEMORY);
        return NULL;
    }

    add_to_list(GFP_ATOMIC, addr, size, func, filename, line);
    return addr;
}

void *_malloc(size_t size, const char *func, const char *filename, int line)
{
    void	*addr;

    if (size > MAXSIZE_ALLOC || !(addr = kmalloc(size, GFP_KERNEL)))
    {
        klog(0,"kmalloc size %x err, too large\n", size);
        set_error(STATUS_NO_MEMORY);
        return NULL;
    }

    add_to_list(GFP_KERNEL, addr, size, func, filename, line);
    return addr;
}

void _free(void *p)
{
    if(p)
    {
        kfree(p);
        remove_from_list(p);
    }
}

void *_calloc(size_t nmemb, size_t size, const char *func, const char *filename, int line)
{
    void	*addr;
    size_t	total = nmemb * size;

    if (total > MAXSIZE_ALLOC || !(addr = _malloc(total, func, filename, line)))
    {
        klog(0,"kmalloc size %x err, too large\n", total);
        set_error(STATUS_NO_MEMORY);
        return NULL;
    }

    memset(addr, 0, total);

    return addr;
}

void *_realloc_atomic(void *ptr, size_t new_size, const char *func, const char* filename, int line)
{
    void *new_ptr;

    if (!new_size)
    {
        _free(ptr);
        return NULL;
    }

    if (!ptr)
        return _malloc_atomic(new_size, func, filename, line);

    new_ptr = _malloc_atomic(new_size, func, filename, line);
    if (new_ptr)
    {
        memcpy(new_ptr, ptr, new_size);
        _free(ptr);
    }

    return new_ptr;
}

void *_realloc(void *ptr, size_t new_size, const char *func, const char* filename, int line)
{
    void *new_ptr;

    if (!new_size)
    {
        _free(ptr);
        return NULL;
    }

    if (!ptr)
        return _malloc(new_size, func, filename, line);

    new_ptr = _malloc(new_size, func, filename, line);
    if (new_ptr)
    {
        memcpy(new_ptr, ptr, new_size);
        _free(ptr);
    }

    return new_ptr;
}

#else

/*stdlib.h*/
void *malloc_atomic(size_t size)
{
    void	*addr;

    if (size > MAXSIZE_ALLOC || !(addr = kmalloc(size, GFP_ATOMIC)))
    {
        klog(0,"kmalloc size %x err, too large\n", size);
        set_error(STATUS_NO_MEMORY);
        return NULL;
    }

    return addr;
}

void *malloc(size_t size)
{
    void	*addr;

    if (size > MAXSIZE_ALLOC || !(addr = kmalloc(size, GFP_KERNEL))) 
    {
        klog(0,"kmalloc size %x err, too large\n", size);
        set_error(STATUS_NO_MEMORY);
        return NULL;
    }

    return addr;
}

void *calloc(size_t nmemb, size_t size)
{
    void	*addr;
    size_t	total = nmemb * size;

    if (total > MAXSIZE_ALLOC || !(addr = kmalloc(total, GFP_KERNEL))) 
    {
        klog(0,"kmalloc size %x err, too large\n", total);
        set_error(STATUS_NO_MEMORY);
        return NULL;
    }

    memset(addr, 0, total);

    return addr;
}

void free(void *p)
{
    if (p)
        kfree(p);
}

void *realloc_atomic(void *ptr, size_t new_size)
{
    void *new_ptr;

    if (!new_size)
    {
        free(ptr);
        return NULL;
    }

    if (!ptr)
        return malloc_atomic(new_size);

    new_ptr = malloc_atomic(new_size);
    if (new_ptr)
    {
        memcpy(new_ptr, ptr, new_size);
        free(ptr);
    }

    return new_ptr;
}

void *realloc(void *ptr, size_t new_size)
{
    void *new_ptr;

    if (!new_size) 
    {
        free(ptr);
        return NULL;
    }

    if (!ptr)
        return malloc(new_size);

    new_ptr = malloc(new_size);
    if (new_ptr) 
    {
        memcpy(new_ptr, ptr, new_size);
        free(ptr);
    }

    return new_ptr;
}
#endif

void exit(int status)
{
    asmlinkage long (*sys_exit)(int error_code) = get_syscall(UK_exit);

    sys_exit(status);

    klog(0,"warnning : The exit() function does not return. \n");
}

void _exit(int status)
{
    klog(0,"NOT IMPLEMENT!\n");
}

void abort(void)
{
    klog(0,"NOT IMPLEMENT!\n");
}

int atexit(void (*func)(void))
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int atoi(const char* str)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

unsigned long  strtoul(const char* str, char**endptr, int base)
{
    return simple_strtoul( str, endptr, base );
}

void perror(const char *s)
{
    klog(0,"%s:errno=%d\n",s,errno);
}

/*stdio.h*/

FILE* fopen(const char* filename, const char* mode) /*for register.c */
{
    FILE* fp;
    struct file *filp = NULL;
    int flags = 0;

    if (!strcmp(mode, "r"))
        flags = O_RDONLY;
    else if (!strcmp(mode, "w"))
        flags = O_WRONLY | O_TRUNC;
    else if (!strcmp(mode, "a"))
        flags = O_APPEND;
    else if (!strcmp(mode, "r+"))
        flags = O_RDWR;
    else if (!strcmp(mode, "w+"))
        flags = O_RDWR | O_TRUNC;
    else if (!strcmp(mode, "a+"))
        flags = O_RDWR | O_APPEND;
    else
    {
        klog(0,"Not Implement mode %s \n",mode);
        return NULL;
    }

    filp = filp_open( filename, flags, 0666 );
    if(IS_ERR(filp))
    {
        klog(0,"filp_open error %d\n", (ULONG)PTR_ERR(filp));
        return NULL;
    }

    fp = malloc(sizeof(FILE));
    if (!fp)
    {
        return NULL;
    }

    memset( fp, 0, sizeof(FILE));
    fp->filp = filp;

    return fp;
}

FILE* fdopen(int fd, const char *mode)
{
    FILE* fp;
    struct file *filp = NULL;
    int flags = 0;

    if (!strcmp(mode, "r"))
        flags = O_RDONLY;
    else if (!strcmp(mode, "w"))
        flags = O_WRONLY; /*fdopen can't truncate file*/
    else if (!strcmp(mode, "a"))
        flags = O_APPEND;
    else if (!strcmp(mode, "r+"))
        flags = O_RDWR;
    else if (!strcmp(mode, "w+"))
        flags = O_RDWR;
    else if (!strcmp(mode, "a+"))
        flags = O_RDWR | O_APPEND;
    else
    {
        klog(0,"Not Implement mode %s \n",mode);
        return NULL;
    }

    filp = fget(fd);
    if(!(filp))
    {
        klog(0,"fget error \n");
        return NULL;
    }

    fp = malloc(sizeof(FILE));
    if (!fp)
    {
        klog(0,"no memory\n");
        return NULL;
    }

    memset( fp, 0, sizeof(FILE));
    filp->f_flags |= flags;
    fp->filp = filp;

    return fp;
}

/* vfs_write() wrapper */
ssize_t filp_write(struct file *filp, void *buf, size_t size)
{
    ssize_t ret;
    loff_t pos;

    PREPARE_KERNEL_CALL;
    pos = filp->f_pos;
    ret = vfs_write(filp, buf, size, &pos);
    filp->f_pos = pos;
    END_KERNEL_CALL;

    return ret;
}

size_t fwrite(const void* buf, size_t size, size_t nmemb, FILE *fp)
{
    unsigned int ret=0;
    size_t len = size * nmemb;
    int pos;

    if ((fp==stderr) || (fp==stdout))
    {
        klog(0," NOT IMPLEMENT!\n");
        return 0;
    }
    else if (fp==stdin)
    {
        klog(0,"stdin NOT IMPLEMENT!\n");
        return 0;
    }

    if(len <= 0)
        return 0;

    if(fp->buf == NULL)
    {
        fp->buf = (char *)__get_free_pages(GFP_KERNEL, 1);
        fp->buflen = PAGE_SIZE * 2;
        fp->validlen = 0;
        fp->bufpos = 0;
        if (!fp->buf)
        {
            set_error(STATUS_NO_MEMORY);
            klog(0,"no memory\n");
            return 0;
        }
    }

    pos = 0;
    while (len > 0)
    {
        if (fp->bufpos + len < PAGE_SIZE)
        {
            memcpy(fp->buf + fp->bufpos, buf + pos, len);
            fp->bufpos += len;
            fp->validlen +=len ;
            break;
        }

        if (!fp->bufpos)
        {
            ret = filp_write(fp->filp, (void*)(buf + pos), PAGE_SIZE);
            if (ret != PAGE_SIZE)
            {
                SYSCALL_RETURN(ret);
            }
            pos += PAGE_SIZE;
            len -= PAGE_SIZE;
        }
        else
        {
            memcpy(fp->buf + fp->bufpos, (void*)(buf + pos), PAGE_SIZE - fp->bufpos);
            ret = filp_write(fp->filp, fp->buf, PAGE_SIZE);
            if (ret != PAGE_SIZE)
            {
                SYSCALL_RETURN(ret);
            }
            pos += PAGE_SIZE - fp->bufpos;
            len -= PAGE_SIZE - fp->bufpos;
            fp->bufpos = 0;
            fp->validlen = 0;
        }
    }

    return ret;
}

int fclose(FILE *fp)
{
    int ret = -1;

    if (fp)
    {
        if (fp->buf)
        {
            ret = filp_write(fp->filp, (fp->buf + fp->bufpos-fp->validlen), fp->validlen);
            free_pages((unsigned long)fp->buf, 1);
            fp->buf = NULL;
            fp->validlen = 0;
        }

        if (fp->filp)
        {
            ret = filp_close(fp->filp, NULL);
        }
        else
        {
            klog(0,"worning : filp_close NULL file \n");
        }

        kfree(fp);
        return ret;
    }

    return ret;
}

int printf(const char* fmt,...)
{
    klog(0,fmt);
    return 0;
}

int fprintf(FILE *fp, const char *fmt, ...)
{
    if ((fp==stderr) || (fp==stdout))
    {
        klog(0," NOT IMPLEMENT!\n");
        return 0;
        //	return printk(fmt);
    }
    else if (fp==stdin)
    {
        klog(0,"stdin NOT IMPLEMENT!\n");
        return 0;
    }
    else
    {
        int ret;
        va_list args;

        if(fp->buf==NULL)
        {
            fp->buf = (char *)__get_free_pages(GFP_KERNEL, 1); //2^1, alloc two pages
            fp->buflen = PAGE_SIZE * 2;
            fp->validlen = 0;
            fp->bufpos = 0;
            if (!fp->buf) 
            {
                set_error(STATUS_NO_MEMORY);
                klog(0,"no memory\n");
                return 0;
            }
        }

        va_start(args, fmt);
        ret = vsnprintf(fp->buf+fp->bufpos, 2 * PAGE_SIZE-fp->bufpos, fmt, args);
        va_end(args);

        if (ret <= 0) 
        {
            set_error(STATUS_INVALID_PARAMETER);
            klog(0,"vsnprintf error\n");
            return ret;
        }
        fp->validlen += (long)ret;
        fp->bufpos += (long)ret;
        if(fp->validlen >= PAGE_SIZE)
        {
            ret = filp_write(fp->filp, fp->buf, PAGE_SIZE);
            if (ret < 0)
            {
                set_error(ret);
                klog(0,"filp_write error\n");
                return ret;
            }
            fp->validlen -= ret;
            memcpy(fp->buf, fp->buf + ret, fp->validlen);
            fp->bufpos = fp->validlen;
        }

        return ret;
    }
}

int fputc(int ch, FILE* fp)
{
    return fprintf(fp, "%c", ch);
}

int fputs(const char* s, FILE* fp)
{
    return fprintf(fp, "%s", s);
}

char *fgets(char* buf, int len, FILE *fp) /* for registry.c */
{
    char *p;
    ssize_t nread;
    struct file *filp;

    if (!len)
        return NULL;

    filp = fp->filp;
    nread = kernel_read(filp, filp->f_pos, buf, (size_t)len - 1);

    if (nread <= 0)
        return NULL;

    p = memchr(buf, '\n', nread);
    if (!p)
    {
        *(buf + nread) = 0;
        filp->f_pos += nread;
    }
    else
    {
        *++p = 0;
        filp->f_pos += (p - buf);
    }

    return buf;
}

int vfprintf(FILE* fp, const char* fmt, va_list args)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int setvbuf(FILE* stream,char*buffer,int mode,size_t size)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

/*string.h*/

/* Duplicate S, returning an identical malloc'd string.  */
char *strdup(const char *s)
{
    size_t len = strlen (s) + 1;
    void *new = malloc (len);

    if (new == NULL)
        return NULL;

    return (char *) memcpy (new, s, len);
}

char *strerror(int err)
{
    klog(0,"NOT IMPLEMENT!\n");
    return NULL;
}

/*from libs/port/mkstemps.c*/ //need __udivdi3, __umoddi3
pid_t getpid(void);
int open(const char *pathname, int flags, ...);

#ifdef __GNUC__
__extension__ typedef unsigned long long gcc_uint64_t;
#else
typedef unsigned long gcc_uint64_t;
#endif

#ifndef TMP_MAX
#define TMP_MAX 16384
#endif

int mkstemps ( char *template, int suffix_len)
{
    static const char letters[]
        = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    static gcc_uint64_t value;
#ifdef HAVE_GETTIMEOFDAY
    struct timeval tv;
#endif
    char *XXXXXX;
    size_t len;
    int count;

    len = strlen (template);

    if ((int) len < 6 + suffix_len
            || strncmp (&template[len - 6 - suffix_len], "XXXXXX", 6))
    {
        return -1;
    }

    XXXXXX = &template[len - 6 - suffix_len];

#ifdef HAVE_GETTIMEOFDAY
    /* Get some more or less random data.  */
    gettimeofday (&tv, NULL);
    value += ((gcc_uint64_t) tv.tv_usec << 16) ^ tv.tv_sec ^ getpid ();
#else
    value += getpid ();
#endif

    for (count = 0; count < TMP_MAX; ++count)
    {
        gcc_uint64_t v = value;
        int fd;

#if 0
        /* Fill in the random bits.  */
        XXXXXX[0] = letters[v % 62];
        v /= 62;
        XXXXXX[1] = letters[v % 62];
        v /= 62;
        XXXXXX[2] = letters[v % 62];
        v /= 62;
        XXXXXX[3] = letters[v % 62];
        v /= 62;
        XXXXXX[4] = letters[v % 62];
        v /= 62;
        XXXXXX[5] = letters[v % 62];
#else
        int mod;

        mod = do_div(v,62); /**/
        XXXXXX[0] = letters[mod];
        mod = do_div(v,62);
        XXXXXX[1] = letters[mod];
        mod = do_div(v,62);
        XXXXXX[2] = letters[mod];
        mod = do_div(v,62);
        XXXXXX[3] = letters[mod];
        mod = do_div(v,62);
        XXXXXX[4] = letters[mod];
        mod = do_div(v,62);
        XXXXXX[5] = letters[mod];
#endif

#ifdef VMS
        fd = open (template, O_RDWR|O_CREAT|O_EXCL, 0600, "fop=tmd");
#else
        fd = open (template, O_RDWR|O_CREAT|O_EXCL, 0600);
#endif
        if (fd >= 0)
            /* The file does not exist.  */
            return fd;

        /* This is a random value.  It is only necessary that the next
           TMP_MAX values generated by adding 7777 to VALUE are different
           with (module 2^32).  */
        value += 7777;
    }

    return -1;
}

/*from libs/wine/casemap.c*/
//#include "casemap.c"
const WCHAR wine_casemap_lower[3802] =
{
    /* index */
    0x01bf, 0x02bf, 0x03bf, 0x044f, 0x054f, 0x064f, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x06af, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x07af, 0x08ae,
    0x0100, 0x09ab, 0x0100, 0x0100, 0x0a2f, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0b2f, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0c1d, 0x0cfb,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0dda,
    /* defaults */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x0041 .. 0x00ff */
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x0100 .. 0x01ff */
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0xff39, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001,
    0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001,
    0x0000, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0xff87, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000,
    0x0000, 0x00d2, 0x0001, 0x0000, 0x0001, 0x0000, 0x00ce, 0x0001,
    0x0000, 0x00cd, 0x00cd, 0x0001, 0x0000, 0x0000, 0x004f, 0x00ca,
    0x00cb, 0x0001, 0x0000, 0x00cd, 0x00cf, 0x0000, 0x00d3, 0x00d1,
    0x0001, 0x0000, 0x0000, 0x0000, 0x00d3, 0x00d5, 0x0000, 0x00d6,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x00da, 0x0001,
    0x0000, 0x00da, 0x0000, 0x0000, 0x0001, 0x0000, 0x00da, 0x0001,
    0x0000, 0x00d9, 0x00d9, 0x0001, 0x0000, 0x0001, 0x0000, 0x00db,
    0x0001, 0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0001, 0x0000, 0x0002,
    0x0001, 0x0000, 0x0002, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001,
    0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001,
    0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0000, 0x0002, 0x0001, 0x0000, 0x0001, 0x0000, 0xff9f, 0xffc8,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    /* 0x0200 .. 0x02ff */
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0xff7e, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x2a2b, 0x0001, 0x0000, 0xff5d, 0x2a28, 0x0000,
    0x0000, 0x0001, 0x0000, 0xff3d, 0x0045, 0x0047, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x0370 .. 0x03ff */
    0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000, 0x0001, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0026, 0x0000,
    0x0025, 0x0025, 0x0025, 0x0000, 0x0040, 0x0000, 0x003f, 0x003f,
    0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0xffc4, 0x0000, 0x0000, 0x0001,
    0x0000, 0xfff9, 0x0001, 0x0000, 0x0000, 0xff7e, 0xff7e, 0xff7e,
    /* 0x0400 .. 0x04ff */
    0x0050, 0x0050, 0x0050, 0x0050, 0x0050, 0x0050, 0x0050, 0x0050,
    0x0050, 0x0050, 0x0050, 0x0050, 0x0050, 0x0050, 0x0050, 0x0050,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x000f, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001,
    0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    /* 0x0500 .. 0x05ff */
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x10a0 .. 0x10ff */
    0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60,
    0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60,
    0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60,
    0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60,
    0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x1c60, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x1e00 .. 0x1eff */
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xe241, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    /* 0x1f01 .. 0x1fff */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0xfff8, 0x0000, 0xfff8, 0x0000, 0xfff8, 0x0000, 0xfff8, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0xfff8, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xffb6, 0xffb6, 0xfff7, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffaa,
    0xffaa, 0xffaa, 0xffaa, 0xfff7, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xff9c, 0xff9c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xfff8,
    0xfff8, 0xff90, 0xff90, 0xfff9, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xff80,
    0xff80, 0xff82, 0xff82, 0xfff7, 0x0000, 0x0000, 0x0000,
    /* 0x2103 .. 0x21ff */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0xe2a3, 0x0000, 0x0000, 0x0000, 0xdf41,
    0xdfba, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x001c,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0010, 0x0010,
    0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0010,
    0x0010, 0x0010, 0x0010, 0x0010, 0x0010, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x247c .. 0x24ff */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a,
    0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a,
    0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a,
    0x001a, 0x001a, 0x001a, 0x001a, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x2c00 .. 0x2cff */
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030,
    0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0030, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0000, 0xd609, 0xf11a, 0xd619, 0x0000, 0x0000, 0x0001,
    0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0xd5e4, 0xd603, 0xd5e1,
    0xd5e2, 0x0000, 0x0001, 0x0000, 0x0000, 0x0001, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xd5c1, 0xd5c1,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0xa612 .. 0xa6ff */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0xa722 .. 0xa7ff */
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001,
    0x0000, 0x0001, 0x0000, 0x75fc, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0001, 0x0000, 0x5ad8, 0x0000, 0x0000, 0x0001, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0000,
    0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0xff21 .. 0xffff */
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    0x0020, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};
const WCHAR wine_casemap_upper[3994] =
{
    /* index */
    0x019f, 0x029f, 0x039f, 0x045a, 0x0556, 0x0656, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x06dd, 0x07dc, 0x08dc,
    0x0100, 0x09d0, 0x0100, 0x0100, 0x0a55, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0b3f, 0x0c3f, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0cfe, 0x0ddb,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100,
    0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0100, 0x0e9a,
    /* defaults */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x0061 .. 0x00ff */
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x02e7, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0x0000, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0x0079,
    /* 0x0100 .. 0x01ff */
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xff18, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0xfed4,
    0x00c3, 0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0x0061, 0x0000, 0x0000,
    0x0000, 0xffff, 0x00a3, 0x0000, 0x0000, 0x0000, 0x0082, 0x0000,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0x0000, 0xffff, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0x0038,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0xfffe, 0x0000,
    0xffff, 0xfffe, 0x0000, 0xffff, 0xfffe, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0xffb1, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0x0000, 0xffff, 0xfffe, 0x0000, 0xffff, 0x0000, 0x0000,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    /* 0x0200 .. 0x02ff */
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0x2a3f,
    0x2a3f, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x2a1f, 0x2a1c, 0x2a1e, 0xff2e, 0xff32, 0x0000, 0xff33, 0xff33,
    0x0000, 0xff36, 0x0000, 0xff35, 0x0000, 0x0000, 0x0000, 0x0000,
    0xff33, 0x0000, 0x0000, 0xff31, 0x0000, 0xa528, 0x0000, 0x0000,
    0xff2f, 0xff2d, 0x0000, 0x29f7, 0x0000, 0x0000, 0x0000, 0xff2d,
    0x0000, 0x29fd, 0xff2b, 0x0000, 0x0000, 0xff2a, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x29e7, 0x0000, 0x0000,
    0xff26, 0x0000, 0x0000, 0xff26, 0x0000, 0x0000, 0x0000, 0x0000,
    0xff26, 0xffbb, 0xff27, 0xff27, 0xffb9, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0xff25, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x0345 .. 0x03ff */
    0x0054, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000, 0x0082, 0x0082,
    0x0082, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffda,
    0xffdb, 0xffdb, 0xffdb, 0x0000, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe1, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffc0,
    0xffc1, 0xffc1, 0x0000, 0xffc2, 0xffc7, 0x0000, 0x0000, 0x0000,
    0xffd1, 0xffca, 0xfff8, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0xffaa, 0xffb0, 0x0007, 0x0000, 0x0000,
    0xffa0, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0x0000,
    0x0000, 0x0000, 0x0000,
    /* 0x0404 .. 0x04ff */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffb0, 0xffb0, 0xffb0, 0xffb0,
    0xffb0, 0xffb0, 0xffb0, 0xffb0, 0xffb0, 0xffb0, 0xffb0, 0xffb0,
    0xffb0, 0xffb0, 0xffb0, 0xffb0, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0xfff1, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff,
    /* 0x0500 .. 0x05ff */
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x1d79 .. 0x1dff */
    0x8a04, 0x0000, 0x0000, 0x0000, 0x0ee6, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x1e01 .. 0x1eff */
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0xffc5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    /* 0x1f00 .. 0x1fff */
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0008, 0x0000, 0x0008, 0x0000, 0x0008, 0x0000, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x004a, 0x004a, 0x0056, 0x0056, 0x0056, 0x0056, 0x0064, 0x0064,
    0x0080, 0x0080, 0x0070, 0x0070, 0x007e, 0x007e, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008, 0x0008,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0000, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xe3db, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0008, 0x0008, 0x0000, 0x0000, 0x0000, 0x0007, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x210c .. 0x21ff */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0xffe4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0xfff0, 0xfff0, 0xfff0, 0xfff0,
    0xfff0, 0xfff0, 0xfff0, 0xfff0, 0xfff0, 0xfff0, 0xfff0, 0xfff0,
    0xfff0, 0xfff0, 0xfff0, 0xfff0, 0x0000, 0x0000, 0x0000, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x247b .. 0x24ff */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffe6, 0xffe6, 0xffe6,
    0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6,
    0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6,
    0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0xffe6, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0x2c16 .. 0x2cff */
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0, 0xffd0,
    0xffd0, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000, 0xd5d5,
    0xd5d8, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000,
    /* 0x2d00 .. 0x2dff */
    0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0,
    0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0,
    0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0,
    0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0,
    0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0xe3a0, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0xa641 .. 0xa6ff */
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0xa723 .. 0xa7ff */
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff,
    0x0000, 0xffff, 0x0000, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0x0000, 0x0000,
    0x0000, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xffff, 0x0000,
    0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000, 0xffff, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    /* 0xff41 .. 0xffff */
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0, 0xffe0,
    0xffe0, 0xffe0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};

/*from libs/wine/config.c*/
//#include "config.c"
#if 1
static const char server_config_dir[] = "/.wine";        /* config dir relative to $HOME */
static const char server_root_prefix[] = "/tmp/.wine-";  /* prefix for server root dir */
static const char server_dir_prefix[] = "/server-";      /* prefix for server dir */
static char *config_dir;
static char *user_name;
static char *server_dir;

//static void fatal_error( const char *err, ... )  __attribute__((noreturn,format(printf,1,2)));
//static void fatal_perror( const char *err, ... )  __attribute__((noreturn,format(printf,1,2)));
static void fatal_error( const char *err, ... );
static void fatal_perror( const char *err, ... );

char* getenv(const char* name)
{
    klog(0,"NOT IMPLEMENT!\n");
    return NULL;
}

static void fatal_error( const char *err, ... )
{
    va_list args;

    va_start( args, err );
    fprintf( stderr, "wine: " );
    vfprintf( stderr, err, args );
    va_end( args );
    exit(1);
}

/* die on a fatal error */
static void fatal_perror( const char *err, ... )
{
    va_list args;

    va_start( args, err );
    fprintf( stderr, "wine: " );
    vfprintf( stderr, err, args );
    perror( " " );
    va_end( args );
    exit(1);
}

/* malloc wrapper */
static void *xmalloc( size_t size )
{
    void *res;

    if (!size) size = 1;
    if (!(res = malloc( size ))) fatal_error( "virtual memory exhausted\n");
    return res;
}

/* strdup wrapper */
static char *xstrdup( const char *str )
{
    size_t len = strlen(str) + 1;
    char *res = xmalloc( len );
    memcpy( res, str, len );
    return res;
}
/* remove all trailing slashes from a path name */
static inline void remove_trailing_slashes( char *path )
{
    int len = strlen( path );
    while (len > 1 && path[len-1] == '/') path[--len] = 0;
}

/* initialize the server directory value */
static void init_server_dir( dev_t dev, ino_t ino )
{
    char *p;
#ifdef HAVE_GETUID
    const unsigned int uid = getuid();
#else
    const unsigned int uid = 0;
#endif

    server_dir = xmalloc( sizeof(server_root_prefix) + 32 + sizeof(server_dir_prefix) +
            2*sizeof(dev) + 2*sizeof(ino) );
    sprintf( server_dir, "%s%u%s", server_root_prefix, uid, server_dir_prefix );
    p = server_dir + strlen(server_dir);

    if (dev != (unsigned long)dev)
        p += sprintf( p, "%lx%08lx-", (unsigned long)((unsigned long long)dev >> 32), (unsigned long)dev );
    else
        p += sprintf( p, "%lx-", (unsigned long)dev );

    if (ino != (unsigned long)ino)
        sprintf( p, "%lx%08lx", (unsigned long)((unsigned long long)ino >> 32), (unsigned long)ino );
    else
        sprintf( p, "%lx", (unsigned long)ino );
}


/* initialize all the paths values */
static void init_paths(void)
{
    struct stat st;

    const char *home = getenv( "HOME" );
    const char *user = NULL;
    const char *prefix = getenv( "WINEPREFIX" );

#ifdef HAVE_GETPWUID
    char uid_str[32];
    struct passwd *pwd = getpwuid( getuid() );

    if (pwd)
    {
        user = pwd->pw_name;
        if (!home) home = pwd->pw_dir;
    }
    if (!user)
    {
        sprintf( uid_str, "%lu", (unsigned long)getuid() );
        user = uid_str;
    }
#else  /* HAVE_GETPWUID */
    if (!(user = getenv( "USER" )))
        fatal_error( "cannot determine your user name, set the USER environment variable\n" );
#endif  /* HAVE_GETPWUID */
    user_name = xstrdup( user );

    /* build config_dir */

    if (prefix)
    {
        config_dir = xstrdup( prefix );
        remove_trailing_slashes( config_dir );
        if (config_dir[0] != '/')
            fatal_error( "invalid directory %s in WINEPREFIX: not an absolute path\n", prefix );
        if (stat( config_dir, &st ) == -1)
        {
            if (errno == ENOENT) return;  /* will be created later on */
            fatal_perror( "cannot open %s as specified in WINEPREFIX", config_dir );
        }
    }
    else
    {
        if (!home) fatal_error( "could not determine your home directory\n" );
        if (home[0] != '/') fatal_error( "your home directory %s is not an absolute path\n", home );
        config_dir = xmalloc( strlen(home) + sizeof(server_config_dir) );
        strcpy( config_dir, home );
        remove_trailing_slashes( config_dir );
        strcat( config_dir, server_config_dir );
        if (stat( config_dir, &st ) == -1)
        {
            if (errno == ENOENT) return;  /* will be created later on */
            fatal_perror( "cannot open %s", config_dir );
        }
    }
    if (!S_ISDIR(st.st_mode)) fatal_error( "%s is not a directory\n", config_dir );
#ifdef HAVE_GETUID
    if (st.st_uid != getuid()) fatal_error( "%s is not owned by you\n", config_dir );
#endif

    init_server_dir( st.st_dev, st.st_ino );
}

/* return the configuration directory ($WINEPREFIX or $HOME/.wine) */
const char *wine_get_config_dir(void)
{
    if (!config_dir) init_paths();
    return config_dir;
}

/* return the full name of the server directory (the one containing the socket) */
const char *wine_get_server_dir(void)
{
    if (!server_dir)
    {
        if (!config_dir) init_paths();
        else
        {
            struct stat st;

            if (stat( config_dir, &st ) == -1)
            {
                if (errno != ENOENT) fatal_error( "cannot stat %s\n", config_dir );
                return NULL;  /* will have to try again once config_dir has been created */
            }
            init_server_dir( st.st_dev, st.st_ino );
        }
    }
    return server_dir;
}

/* return the build id string */
const char wine_build[] = "wine-1.6-longene";
const char *wine_get_build_id(void)
{
    extern const char wine_build[];
    return wine_build;
}
#endif

/*from libs/wine/strings.c*/
int strncmpiW( const WCHAR *str1, const WCHAR *str2, int n )
{
    int ret = 0;
    for ( ; n > 0; n--, str1++, str2++)
        if ((ret = tolowerW(*str1) - tolowerW(*str2)) || !*str1) break;
    return ret;
}

int memicmpW( const WCHAR *str1, const WCHAR *str2, int n )
{
    int ret = 0;
    for ( ; n > 0; n--, str1++, str2++)
        if ((ret = tolowerW(*str1) - tolowerW(*str2))) break;
    return ret;
}

/* format a WCHAR string according to a printf format; helper for vsnprintfW */
static size_t format_string( WCHAR *buffer, size_t len, const char *format, const WCHAR *str, int str_len )
{
    size_t count = 0;
    int i, left_align = 0, width = 0, max = 0;

    assert( *format == '%' );
    format++; /* skip '%' */

    while (*format == '0' || *format == '+' || *format == '-' || *format == ' ' || *format == '#')
    {
        if (*format == '-') left_align = 1;
        format++;
    }

    while (isdigit(*format)) width = width * 10 + *format++ - '0';

    if (str_len == -1) str_len = strlenW( str );
    if (*format == '.')
    {
        format++;
        while (isdigit(*format)) max = max * 10 + *format++ - '0';
        if (max > str_len) max = str_len;
    }
    else max = str_len;

    if (*format == 'h' || *format == 'l') format++;

    assert( *format == 's' );

    if (!left_align && width > max)
    {
        for (i = 0; i < width - max; i++)
        {
            if (count++ < len)
                *buffer++ = ' ';
        }
    }

    if (count < len)
        memcpy( buffer, str, min( max, (int)(len - count) ) * sizeof(WCHAR) );
    count += max;
    buffer += max;

    if (left_align && width > max)
    {
        for (i = 0; i < width - max; i++)
        {
            if (count++ < len)
                *buffer++ = ' ';
        }
    }
    return count;
}

int vsnprintfW(WCHAR *str, size_t len, const WCHAR *format, va_list valist)
{
    unsigned int written = 0;
    const WCHAR *iter = format;
    char bufa[512], fmtbufa[64], *fmta;

    while (*iter)
    {
        while (*iter && *iter != '%')
        {
            if (written++ < len)
                *str++ = *iter;
            iter++;
        }
        if (*iter == '%')
        {
            if (iter[1] == '%')
            {
                if (written++ < len)
                    *str++ = '%'; /* "%%"->'%' */
                iter += 2;
                continue;
            }

            fmta = fmtbufa;
            *fmta++ = *iter++;
            while (*iter == '0' ||
                    *iter == '+' ||
                    *iter == '-' ||
                    *iter == ' ' ||
                    *iter == '*' ||
                    *iter == '#')
            {
                if (*iter == '*')
                {
                    char *buffiter = bufa;
                    int fieldlen = va_arg(valist, int);
                    sprintf(buffiter, "%d", fieldlen);
                    while (*buffiter)
                        *fmta++ = *buffiter++;
                }
                else
                    *fmta++ = *iter;
                iter++;
            }

            while (isdigit(*iter))
                *fmta++ = *iter++;

            if (*iter == '.')
            {
                *fmta++ = *iter++;
                if (*iter == '*')
                {
                    char *buffiter = bufa;
                    int fieldlen = va_arg(valist, int);
                    sprintf(buffiter, "%d", fieldlen);
                    while (*buffiter)
                        *fmta++ = *buffiter++;
                    iter++;
                }
                else
                    while (isdigit(*iter))
                        *fmta++ = *iter++;
            }
            if (*iter == 'h' || *iter == 'l')
                *fmta++ = *iter++;

            switch (*iter)
            {
                case 's':
                    {
                        static const WCHAR none[] = { '(','n','u','l','l',')',0 };
                        const WCHAR *wstr = va_arg(valist, const WCHAR *);
                        size_t remaining = written < len ? len - written : 0;
                        size_t count;

                        *fmta++ = 's';
                        *fmta = 0;
                        count = format_string( str, remaining, fmtbufa, wstr ? wstr : none, -1 );
                        str += min( count, remaining );
                        written += count;
                        iter++;
                        break;
                    }

                case 'c':
                    {
                        WCHAR wstr;
                        size_t remaining = written < len ? len - written : 0;
                        size_t count;

                        wstr = va_arg(valist, int);
                        *fmta++ = 's';
                        *fmta = 0;
                        count = format_string( str, remaining, fmtbufa, &wstr, 1 );
                        str += min( count, remaining );
                        written += count;
                        iter++;
                        break;
                    }

                default:
                    {
                        /* For non wc types, use system sprintf and append to wide char output */
                        /* FIXME: for unrecognised types, should ignore % when printing */
                        char *bufaiter = bufa;
                        if (*iter == 'p')
                            sprintf(bufaiter, "%0*lX", 2 * (int)sizeof(void*),
                                    (unsigned long)va_arg(valist, void *));
                        else
                        {
                            *fmta++ = *iter;
                            *fmta = '\0';
                            if (*iter == 'a' || *iter == 'A' ||
                                    *iter == 'e' || *iter == 'E' ||
                                    *iter == 'f' || *iter == 'F' || 
                                    *iter == 'g' || *iter == 'G')
                                sprintf(bufaiter, fmtbufa, va_arg(valist, double));
                            else
                            {
                                /* FIXME: On 32 bit systems this doesn't handle int 64's. */
                                sprintf(bufaiter, fmtbufa, va_arg(valist, void *));
                            }
                        }
                        while (*bufaiter)
                        {
                            if (written++ < len)
                                *str++ = *bufaiter;
                            bufaiter++;
                        }
                        iter++;
                        break;
                    }
            }
        }
    }
    if (len)
    {
        if (written >= len)
            str--;
        *str++ = 0;
    }

    /* FIXME: POSIX [v]snprintf() returns the equivalent of written, not -1, on short buffer. */
    return written < len ? (int)written : -1;
}

int vsprintfW( WCHAR *str, const WCHAR *format, va_list valist )
{
    return vsnprintfW( str, INT_MAX, format, valist );
}

int snprintfW( WCHAR *str, size_t len, const WCHAR *format, ...)
{
    int retval;
    va_list valist;
    va_start(valist, format);
    retval = vsnprintfW(str, len, format, valist);
    va_end(valist);
    return retval;
}

int sprintfW( WCHAR *str, const WCHAR *format, ...)
{
    int retval;
    va_list valist;
    va_start(valist, format);
    retval = vsnprintfW(str, INT_MAX, format, valist);
    va_end(valist);
    return retval;
}

/*time.h*/
#define TICKSPERSEC        10000000
#define SECSPERDAY         86400
/* 1601 to 1970 is 369 years plus 89 leap days */
#define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)SECSPERDAY)
#define TICKS_1601_TO_1970 (SECS_1601_TO_1970 * TICKSPERSEC)

time_t time(time_t * v)
{
    struct timeval now;
    LARGE_INTEGER time;
    ULONGLONG t;

    PREPARE_KERNEL_CALL;
    do_gettimeofday(&now);
    END_KERNEL_CALL;


    time.QuadPart = now.tv_sec * (ULONGLONG)TICKSPERSEC  + TICKS_1601_TO_1970 + now.tv_usec * 10;
    t = ((ULONGLONG)time.u.HighPart << 32) | time.u.LowPart;
    t = do_div(t,TICKSPERSEC) - TICKS_1601_TO_1970;

    return t;
}

#undef timeout_t
#if BITS_PER_LONG == 32
#define timeout_t long long
#elif BITS_PER_LONG == 64
#define timeout_t long
#endif

timeout_t get_current_time(void)
{
    struct timeval now;

    PREPARE_KERNEL_CALL;
    do_gettimeofday(&now);
    END_KERNEL_CALL;

    return (timeout_t)now.tv_sec * (timeout_t)TICKSPERSEC  + now.tv_usec * 10 + TICKS_1601_TO_1970;
}

#undef timeout_t
#undef TICKSPERSEC
#undef SECSPERDAY
#undef SECS_1601_TO_1970
#undef TICKS_1601_TO_1970


/* for major() */
unsigned int gnu_dev_major (unsigned long long int dev)
{
    return ((dev >> 8) & 0xfff) | ((unsigned int) (dev >> 32) & ~0xfff);
}

unsigned int gnu_dev_minor (unsigned long long int dev)
{
    return (dev & 0xff) | ((unsigned int) (dev >> 12) & ~0xff);
}

unsigned long long int gnu_dev_makedev (unsigned int major, unsigned int minor)
{
    return ((minor & 0xff) | ((major & 0xfff) << 8)
            | (((unsigned long long int) (minor & ~0xff)) << 12)
            | (((unsigned long long int) (major & ~0xfff)) << 32));
}


/*unistd.h*/

long close(unsigned int fd)
{
    long ret;
    asmlinkage	long (*sys_close)(unsigned int fd) = get_syscall(UK_close);

    PREPARE_KERNEL_CALL;
    if (!current->files) /* in this case, close is called after do_exit */
        ret = 0;
    else
        ret = sys_close(fd);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

struct task_struct *uk_find_task_by_pid(pid_t pid)
{
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19))
    struct task_struct *t;

    rcu_read_lock();
    t = pid_task(find_pid_ns(pid, ns_of_pid(task_pid(current))), PIDTYPE_PID);
    rcu_read_lock();

    return t;
#else
    return find_task_by_pid(pid);
#endif
}

int attach_files(struct task_struct *task, struct files_struct *files)
{
    if (files)
    {
        task_lock(task);
        task->files = files;
        task_unlock(task);
        return 0;
    }
    else
    {
        return -1;
    }
}

void restore_files(struct task_struct *task, struct files_struct *orig_files)
{
    task_lock(task);
    if (task->files != orig_files)
    {
        task->files = orig_files;
    }
    task_unlock(task);
}

struct files_struct *get_files(struct task_struct *task)
{
    struct files_struct *files;

    task_lock(task);
    files = task->files;
    if (files)
        atomic_inc(&files->count);
    task_unlock(task);

    return files;
}

void put_files(struct files_struct *files)
{
    if (atomic_dec_and_test(&files->count))
    {
        klog(0,"NON IMPLEMENT \n");
    }
}

int close_fd_by_pid(int fd, pid_t pid)
{
    int ret = 0;
    struct files_struct *ofiles, *tfiles;
    struct task_struct *task;

    task = uk_find_task_by_pid(pid);
    if (!task)
    {
        return -ESRCH;
    }

    ofiles = get_files(current);

    tfiles = get_files(task);
    if (!tfiles)
    {
        ret = -EBADF;
        goto out;
    }

    ret = attach_files(current, tfiles);
    put_files(tfiles);
    if (ret<0) goto out;

    ret = close(fd);
    restore_files(current, ofiles);

out:
    if (ofiles) put_files(ofiles);
    return ret;
}

int open(const char *filename, int flags, ...)
{
    int ret;
    int mode = 0;
    asmlinkage long (*sys_open)(const char __user *filename,
            int flags, int mode) = get_syscall(UK_open);

    if (flags & O_CREAT)
    {
        va_list arg;
        va_start(arg, flags);
        mode = va_arg(arg, int);
        va_end(arg);
    }

    PREPARE_KERNEL_CALL;
    ret = sys_open(filename, flags, mode);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

ssize_t read(unsigned int fd, void *buf, size_t size)
{
    ssize_t ret;
    asmlinkage	long (*sys_read)(unsigned int, char*, size_t) = get_syscall(UK_read);

    PREPARE_KERNEL_CALL;
    ret = sys_read(fd, buf, size);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

ssize_t write(int fd, const void *buf, size_t count)
{
    int ret;
    asmlinkage long (*sys_write)(unsigned int fd, const char __user *buf,
            size_t count) = get_syscall(UK_write);

    PREPARE_KERNEL_CALL;
    ret = sys_write(fd, buf, count);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

ssize_t pread(int fd, void *buf, size_t count, off_t offset)
{
    struct file *file;
    ssize_t ret = -EBADF;

    file = fget(fd);
    if (file)
    {
        loff_t pos = offset; /* from start of the file */
        PREPARE_KERNEL_CALL;
        ret = vfs_read(file, buf, count, &pos);
        END_KERNEL_CALL;
        fput(file);
    }

    SYSCALL_RETURN(ret);
}

ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset)
{
    struct file *file;
    ssize_t ret = -EBADF;

    file = fget(fd);
    if (file)
    {
        loff_t pos = offset; /* from start of the file */
        PREPARE_KERNEL_CALL;
        ret = vfs_write(file, buf, count, &pos);
        END_KERNEL_CALL;
        fput(file);
    }

    SYSCALL_RETURN(ret);
}

ssize_t readv(int fd, const struct iovec *iov, int iovcnt)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

ssize_t writev(int fd, const struct iovec *iov, int iovcnt)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

ssize_t preadv(int fd, const struct iovec *iov, int iovcnt, off_t offset)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt, off_t offset)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

long dup(unsigned int fd)
{
    long ret;
    asmlinkage	long (*sys_dup)(unsigned int) = get_syscall(UK_dup);

    PREPARE_KERNEL_CALL;
    ret = sys_dup(fd);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

long dup2(unsigned int oldfd, unsigned int newfd)
{
    long ret;
    asmlinkage	long (*sys_dup2)(unsigned int, unsigned int) = get_syscall(UK_dup2);

    PREPARE_KERNEL_CALL;
    ret = sys_dup2(oldfd, newfd);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int stat(const char *filename, struct stat *st)
{
    int ret;
    asmlinkage long (*sys_newstat)(char __user *filename,
            struct stat __user *statbuf) = get_syscall(UK_newstat);

    PREPARE_KERNEL_CALL;
    ret = sys_newstat((char __user *)filename, st);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int fstat(unsigned int fd, struct stat *st)
{
    int ret;
    asmlinkage long (*sys_newfstat)(unsigned int fd, struct stat __user *statbuf)
        = get_syscall(UK_newfstat);

    PREPARE_KERNEL_CALL;
    ret = sys_newfstat(fd, st);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int lstat(const char *path, void *buf)
{
    int ret = 0;
    asmlinkage long (*sys_newlstat)(char __user *filename,
            struct stat __user *statbuf) = get_syscall(UK_newlstat);

    PREPARE_KERNEL_CALL;
    ret = sys_newlstat((char __user *)path, buf);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int symlink(const char *oldpath, const char *newpath)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int unlink(const char *pathname)
{
    int ret;
    asmlinkage	long (*sys_unlink)(const char*) = get_syscall(UK_unlink);

    PREPARE_KERNEL_CALL;
    ret = sys_unlink(pathname);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int rename(const char *oldpath, const char *newpath)
{
    int ret;
    asmlinkage	long (*sys_rename)(const char*, const char*) = get_syscall(UK_rename);

    PREPARE_KERNEL_CALL;
    ret = sys_rename(oldpath, newpath);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int truncate(const char *path, off_t length)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int ftruncate(int fd, off_t length)
{
    int ret=0;
    asmlinkage long (*sys_ftruncate)(unsigned int fd, unsigned long length)
        = get_syscall(UK_ftruncate);

    ret = sys_ftruncate(fd, length);

    SYSCALL_RETURN(ret);
}

int statfs(const char *path, struct statfs *buf)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int fstatfs(int fd, struct statfs *buf)
{
    int ret;
    asmlinkage long (*sys_fstatfs)(unsigned int fd, struct statfs __user *buf)
        = get_syscall(UK_fstatfs);

    PREPARE_KERNEL_CALL;
    ret = sys_fstatfs(fd, buf);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int rmdir(const char *pathname)
{
    int ret;
    asmlinkage long (*sys_rmdir)(const char __user *pathname) = get_syscall(UK_rmdir);

    PREPARE_KERNEL_CALL;
    ret = sys_rmdir(pathname);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int mkdir(const char *pathname, mode_t mode)
{
    long ret;
    asmlinkage	long (*sys_mkdir)(const char *pathname, int mode) = get_syscall(UK_mkdir);

    PREPARE_KERNEL_CALL;
    ret = sys_mkdir(pathname, mode);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int chdir(const char *path)
{
    int ret;
    asmlinkage long (*sys_chdir)(const char __user *filename) = get_syscall(UK_chdir);

    ret = sys_chdir(path);

    SYSCALL_RETURN(ret);
}

int fchdir(int fd)
{
    int ret;
    asmlinkage long (*sys_fchdir)(unsigned int fd) = get_syscall(UK_fchdir);

    ret = sys_fchdir(fd);

    SYSCALL_RETURN(ret);
}

int fsync(int fd)
{
    int ret;
    asmlinkage long (*sys_fsync)(unsigned int fd) = get_syscall(UK_fsync);

    ret = sys_fsync(fd);

    SYSCALL_RETURN(ret);
}

int chmod(const char *path, mode_t mode)
{
    int ret;
    asmlinkage long (*sys_chmod)(const char __user *filename, mode_t mode) = get_syscall(UK_chmod);

    PREPARE_KERNEL_CALL;
    ret = sys_chmod(path, mode);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int fchmod(int fd, mode_t mode)
{
    long ret;
    asmlinkage long (*sys_fchmod)(unsigned int fd, mode_t mode) = get_syscall(UK_fchmod);

    ret = sys_fchmod(fd, mode);

    SYSCALL_RETURN(ret);
}

int fcntl(int fd, unsigned int cmd, ... /*unsigned long arg*/)
{
    int ret;
    va_list ap;
    unsigned long arg;
    asmlinkage long (*sys_fcntl)(unsigned int fd, unsigned int cmd, unsigned long arg) = get_syscall(UK_fcntl);

    va_start(ap, cmd);
    arg = va_arg(ap, unsigned long);
    va_end(ap);

    PREPARE_KERNEL_CALL;
    ret = sys_fcntl(fd, cmd, arg);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

pid_t setsid(void)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int gettimeofday(void *tv, void *tz)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int settimeofday(const void *tv, const void *tz)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int usleep(unsigned int usec)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int clock_settime(clockid_t clk_id, const void *tp)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int clock_gettime(clockid_t clk_id, void *tp)
{
    int ret = 0 ;
    asmlinkage long (*sys_clock_gettime)(clockid_t which_clock,
            struct timespec __user *tp) = get_syscall(UK_clock_gettime);

    PREPARE_KERNEL_CALL;
    ret = sys_clock_gettime( clk_id, tp);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);

}

/*signal.h*/

__sighandler_t  signal(int sig, __sighandler_t func)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

int  raise(int sig)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

unsigned int alarm(unsigned int seconds)
{
    int ret;
    asmlinkage long (*sys_alarm)(unsigned int seconds) = get_syscall(UK_alarm);

    ret = sys_alarm(seconds);

    SYSCALL_RETURN(ret);
}

//int sigaction(int sig, const struct old_sigaction __user *act, struct old_sigaction __user *oldact)
int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact)
{
    long ret;
    asmlinkage int (*sys_sigaction)(int sig, const struct old_sigaction __user *act,
            struct old_sigaction __user *oact) = get_syscall(UK_sigaction);

    PREPARE_KERNEL_CALL;
    ret = sys_sigaction(sig, (const struct old_sigaction __user *)act, (struct old_sigaction __user *)oldact); 
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int kill(pid_t pid, int sig)
{
    long ret;
    asmlinkage long (*sys_kill)(int, int) = get_syscall(UK_kill);

    PREPARE_KERNEL_CALL;
    ret = sys_kill(pid, sig);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

ssize_t filp_pread(struct file *filp, char *buf, size_t count, off_t pos)
{
    ssize_t ret;
    loff_t lpos = (loff_t)pos;

    PREPARE_KERNEL_CALL;
    ret = vfs_read(filp, buf, count, &lpos);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

ssize_t filp_pwrite(struct file *filp, const char *buf, size_t count, off_t pos)
{
    ssize_t ret;
    loff_t lpos = (loff_t)pos;

    PREPARE_KERNEL_CALL;
    ret = vfs_write(filp, buf, count, &lpos);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

ssize_t readlink(const char *path, char *buf, size_t bufsiz)
{
    long ret;
    asmlinkage	long (*sys_readlink)(const char*, char*, int) = get_syscall(UK_readlink);

    PREPARE_KERNEL_CALL;
    ret = sys_readlink(path, buf, bufsiz);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

/*poll.h*/
int poll(struct pollfd *pfds, unsigned int nfds, long timeout_msecs)
{
    long ret;
    asmlinkage	long (*sys_poll)(struct pollfd*, unsigned int, long) = get_syscall(UK_poll);

    PREPARE_KERNEL_CALL;
    ret = sys_poll(pfds, nfds, timeout_msecs);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

/*epoll.h*/
int epoll_create(int size)
{
    return -1;
#if 0
    int ret;
    asmlinkage long (*sys_epoll_create)(int size) = get_syscall(UK_epoll_create);

    ret = sys_epoll_create(size);

    SYSCALL_RETURN(ret);
#endif
}

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
{
    return -1;
#if 0
    int ret;
    asmlinkage long (*sys_epoll_ctl)(int epfd, int op, int fd,
            struct epoll_event __user *event) = get_syscall(UK_epoll_ctl);

    ret = sys_epoll_ctl(epfd, op, fd, event);

    SYSCALL_RETURN(ret);
#endif
}

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)
{
    return -1;
#if 0
    int ret;
    asmlinkage long (*sys_epoll_wait)(int epfd, struct epoll_event __user *events,
            int maxevents, int timeout) = get_syscall(UK_epoll_wait);

    ret=sys_epoll_wait(epfd, events, maxevents, timeout);

    SYSCALL_RETURN(ret);
#endif
}

/*socket.h*/
long socket(int family, int type, int protocol)
{
    int ret;
    asmlinkage	long (*sys_socket)(int, int, int) = get_syscall(UK_socket);
    ret = sys_socket(family, type, protocol);
    SYSCALL_RETURN(ret);
}

long bind(int sockfd, const struct sockaddr *addr, int addrlen)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}
long listen(int sockfd, int backlog)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}
long connect(int sockfd, const struct sockaddr *addr, int addrlen)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}
long accept(int fd, struct sockaddr* peer_sockaddr, int* peer_addrlen)
{
    long ret;
    asmlinkage	long (*sys_accept)(int, struct sockaddr*, int*) = get_syscall(UK_accept);

    PREPARE_KERNEL_CALL;
    ret = sys_accept(fd, peer_sockaddr, peer_addrlen);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

long shutdown(int fd, int how)
{
    long ret;
    asmlinkage	long (*sys_shutdown)(int, int) = get_syscall(UK_shutdown);

    PREPARE_KERNEL_CALL;
    ret = sys_shutdown(fd, how);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}


long recv(int fd, void *buf, size_t size, unsigned flags)
{
    long ret;
    asmlinkage long (*sys_recv)(int, void __user *, size_t, unsigned) = get_syscall(UK_recv);

    PREPARE_KERNEL_CALL;
    ret = sys_recv(fd, buf, size, flags);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
        struct sockaddr *src_addr, int *addrlen)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
#if 0
    long ret;
    asmlinkage long (*sys_recvfrom)(int, void*, size_t, unsigned, struct sockaddr*, int*) 
        = get_syscall(UK_recvfrom);

    PREPARE_KERNEL_CALL;
    ret = sys_recvfrom(fd, buf, size, flags, NULL, NULL);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
#endif
}
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
#if 0
    int ret;
    asmlinkage long (*sys_recvmsg)(int, struct msghdr __user*, unsigned)
        = get_syscall(UK_recvmsg);

    PREPARE_KERNEL_CALL;
    ret = sys_recvmsg(sockfd,msg,flags);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
#endif
}

ssize_t send(int sockfd, const void *buf, size_t len, int flags)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
        const struct sockaddr *dest_addr, int addrlen)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
#if 0
    int ret;
    asmlinkage long (*sys_sendmsg)(int, const struct msghdr __user*, unsigned)
        = get_syscall(UK_sendmsg);

    PREPARE_KERNEL_CALL;
    ret = sys_sendmsg(sockfd,msg,flags);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
#endif
}

long socketpair(int family, int type, int protocol, int *sockvec)
{
    long ret;
    asmlinkage	long (*sys_socketpair)(int, int, int, int*) = get_syscall(UK_socketpair);

    PREPARE_KERNEL_CALL;
    ret = sys_socketpair(family, type, protocol, sockvec);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

long getsockopt(int fd, int level, int optname, void *optval, unsigned int *optlen)
{
    long ret;
    asmlinkage	long (*sys_getsockopt)(int fd, int level, int optname,
            char * optval, int * optlen) = get_syscall(UK_getsockopt);

    PREPARE_KERNEL_CALL;
    ret = sys_getsockopt(fd, level, optname, optval, optlen);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int setsockopt(int fd, int level, int optname, const void *optval, int optlen)
{
    long ret;
    asmlinkage	long (*sys_setsockopt)(int fd, int level, int optname,
            char * optval, int optlen) = get_syscall(UK_setsockopt);

    PREPARE_KERNEL_CALL;
    ret = sys_setsockopt(fd, level, optname, (char *)optval, optlen);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int getsockname(int sockfd, struct sockaddr *addr, int* addrlen )
{
    int ret;
    asmlinkage long (*sys_getsockname)(int, struct sockaddr __user*, int __user*)
        = get_syscall(UK_getsockname);

    PREPARE_KERNEL_CALL;
    ret = sys_getsockname(sockfd,addr,addrlen);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int getpeername(int sockfd, struct sockaddr *addr, int* addrlen )
{
    int ret;
    asmlinkage long (*sys_getpeername)(int, struct sockaddr __user*, int __user*)
        = get_syscall(UK_getpeername);

    PREPARE_KERNEL_CALL;
    ret = sys_getpeername(sockfd,addr,addrlen);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int inotify_init(void)
{
    int ret;
    asmlinkage long (*sys_inotify_init)(void) = get_syscall(UK_inotify_init);

    PREPARE_KERNEL_CALL;
    ret = sys_inotify_init();
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int inotify_add_watch(int fd,const char *pathname,unsigned int mask)
{
    int ret;
    asmlinkage long (*sys_inotify_add_watch)(int, const char __user*, u32)
        = get_syscall(UK_inotify_add_watch);

    PREPARE_KERNEL_CALL;
    ret = sys_inotify_add_watch(fd,pathname,mask);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int inotify_rm_watch(int fd,int wd)
{
    int ret;
    asmlinkage long (*sys_inotify_rm_watch)(int, __s32) = get_syscall(UK_inotify_rm_watch);

    PREPARE_KERNEL_CALL;
    ret = sys_inotify_rm_watch(fd,wd);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

/*mman.h*/
int mmap(unsigned long addr, size_t len, int prot, int flags, int fd, off_t off)
{
    int ret;

    asmlinkage long (*sys_mmap_pgoff)(unsigned long addr, unsigned long len,
            unsigned long prot, unsigned long flags,
            unsigned long fd, unsigned long pgoff) = get_syscall(UK_mmap_pgoff);

    ret = -EINVAL;
    if (off & ~PAGE_MASK)
        goto out;

    ret = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
out:
    SYSCALL_RETURN(ret);
}

int munmap(unsigned long addr, size_t length)
{
    int ret;
    asmlinkage long (*sys_munmap)(unsigned long addr, size_t len) = get_syscall(UK_munmap);

    ret = sys_munmap(addr, length);

    SYSCALL_RETURN(ret);
}

int pipe(int *fildes)
{
    int ret;
    asmlinkage long (*sys_pipe)(int*) = get_syscall(UK_pipe);

    PREPARE_KERNEL_CALL;
    ret = sys_pipe(fildes); 
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

pid_t fork(void)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

pid_t getpid(void)
{
    return task_tgid_vnr(current);
}

pid_t getppid(void)
{
    int pid;

    rcu_read_lock();
    pid = task_tgid_vnr(current->real_parent);
    rcu_read_unlock();

    return pid;
}

uid_t getuid(void)
{
    return current_uid();
}
uid_t geteuid(void)
{
    return current_euid();
}
int setuid(uid_t uid)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

pid_t wait(int *status)
{
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

pid_t waitpid(pid_t pid, int *status, int options)
{
    int ret;
    asmlinkage long (*sys_waitpid)(pid_t pid, int __user *stat_addr, int options) = get_syscall(UK_waitpid);

    PREPARE_KERNEL_CALL
        ret = sys_waitpid(pid, status, options);
    END_KERNEL_CALL

        SYSCALL_RETURN(ret);
}

long ptrace(int request, ...)
{
    int ret;
    pid_t pid;
    unsigned long addr,data,tmp;
    va_list ap;
    asmlinkage long (*sys_ptrace)(long request, long pid, long addr, long data) = get_syscall(UK_ptrace);
    mm_segment_t oldfs;
    struct task_struct *child;

    va_start(ap, request);
    pid = va_arg(ap, pid_t);
    addr = va_arg(ap, unsigned long);
    data = va_arg(ap, unsigned long);
    va_end(ap);

    child = uk_find_task_by_pid(pid);
    if (!child)
    {
        klog(0,"child is killed \n");
        ret = -ESRCH;
        SYSCALL_RETURN(ret);
    }

    if (child->tgid == current->tgid)
    {
        switch(request)
        {
            case PTRACE_PEEKDATA:
                if(get_user(tmp, (unsigned long __user*)addr))
                {
                    klog(0,"error:get_user. addr %08x data %08x tmp %08x\n", (UINT)addr, (UINT)data, (UINT)tmp);
                    ret = -EFAULT;
                    SYSCALL_RETURN(ret);
                }
                return tmp;

            case PTRACE_POKEDATA:
                if (put_user(data, (unsigned long __user*)addr))
                {
                    klog(0,"error:put_user. addr %08x data %08x tmp %08x\n", (UINT)addr, (UINT)data, (UINT)tmp);
                    ret = -EFAULT;
                    SYSCALL_RETURN(ret);
                }
                return 0;

                /* for get_thread_context() */
            case PTRACE_PEEKUSR:
                {
                    long (*arch_ptrace)(struct task_struct *child, long request,
                            unsigned long addr, unsigned long data) = get_kernel_proc_address("arch_ptrace");

                    if (!arch_ptrace)
                    {
                        klog(0,"don't find arch_ptrace() \n");
                        return 0;
                    }

                    data = (unsigned long)&tmp;

                    oldfs = get_fs();
                    set_fs(KERNEL_DS);
                    ret = arch_ptrace(current, request, addr, data);
                    set_fs(oldfs);

                    if (ret >= 0)
                        return tmp;
                    else
                        SYSCALL_RETURN(ret);
                }

                /* for set_thread_context() */
            case PTRACE_POKEUSR: /* write the word at location addr in the USER area */
                {
                    long (*arch_ptrace)(struct task_struct *child, long request,
                            unsigned long addr, unsigned long data) = get_kernel_proc_address("arch_ptrace");

                    if (!arch_ptrace)
                    {
                        klog(0,"don't find arch_ptrace() \n");
                        return 0;
                    }

                    ret = arch_ptrace(current, request, addr, data);

                    SYSCALL_RETURN(ret);
                }

            default:
                klog(0,"NOT IMPLEMENT! type 0x%x\n",request);
                return 0;
        }
    }

    if(request>0 && request<4) /* PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR */
        data = (unsigned long)&tmp;

    oldfs = get_fs();
    if ( request != PTRACE_PEEKUSR && (ULONG)addr < (ULONG)TASK_SIZE )
        set_fs(get_ds());
    else
        set_fs(KERNEL_DS);
    ret = sys_ptrace(request, (long)pid, (long)addr, (long)data);
    set_fs(oldfs);

    if (ret>=0 && request>0 && request<4)
        return tmp;

    SYSCALL_RETURN(ret);
}

long sysconf(int name)
{
    if (name == _SC_PAGESIZE)
    {
        return PAGE_SIZE;
    }
    else
    {
        klog(0,"NOT IMPLEMENT!\n");
        return 0;
    }
}

int syscall(int number, ...)
{
    va_list ap;
    int ret;

    switch(number)
    {
        case __NR_tgkill:
            {
                asmlinkage long (*sys_tgkill)(int tgid, int pid, int sig) = get_syscall(UK_tgkill);
                int tgid, pid, sig;
                struct task_struct *target = NULL;
                pid_t old_tgid = -1;
                char need_restore = 0;

                va_start(ap, number);
                tgid = va_arg(ap, int);
                pid = va_arg(ap, int);
                sig= va_arg(ap, int);
                va_end(ap);

                target = uk_find_task_by_pid(pid);
                if (!target)
                {
                    ret = -ESRCH;
                    SYSCALL_RETURN(ret);
                }
                else if (target->tgid != current->tgid)
                {
                    old_tgid = target->tgid;
                    target->tgid = current->tgid;
                    need_restore = 1;
                }

                ret = sys_tgkill(tgid, pid, sig);

                if (need_restore)
                {
                    target->tgid = old_tgid;
                }

                SYSCALL_RETURN(ret);
            }

        case __NR_tkill:
            {
                asmlinkage long (*sys_tkill)(int pid, int sig) = get_syscall(UK_tkill);
                int pid, sig;

                va_start(ap, number);
                pid = va_arg(ap, int);
                sig= va_arg(ap, int);
                va_end(ap);

                ret = sys_tkill(pid, sig);

                SYSCALL_RETURN(ret);
            }

        default:
            klog(0,"NOT IMPLEMENT!\n");
            return 0;
    }
}

/* sys/resource.h*/
int getrlimit(int resource, struct rlimit *rlim)
{
    int ret;
    asmlinkage long (*sys_getrlimit)(unsigned int resource,
            struct rlimit __user *rlim) = get_syscall(UK_getrlimit);

    ret = sys_getrlimit(resource, rlim);

    SYSCALL_RETURN(ret);
}

int uk_sched_setaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
{
    struct cpumask kernel_mask;
    int ret;

    asmlinkage long (*sys_sched_setaffinity)(pid_t pid, unsigned int len,
            unsigned long __user *user_mask_ptr) = get_syscall(UK_sched_setaffinity);

    memcpy(&kernel_mask, mask, sizeof(struct cpumask));

    PREPARE_KERNEL_CALL;
    ret = sys_sched_setaffinity(pid, sizeof(struct cpumask), (unsigned long __user *)&kernel_mask);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int uk_sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)
{
    struct cpumask kernel_mask;
    int ret;
    asmlinkage long (*sys_sched_getaffinity)(pid_t pid, unsigned int len,
            unsigned long __user *user_mask_ptr) = get_syscall(UK_sched_getaffinity);

    PREPARE_KERNEL_CALL;
    ret = sys_sched_getaffinity(pid, sizeof(struct cpumask), (unsigned long __user *)&kernel_mask);
    END_KERNEL_CALL;

    if (ret == 0)
    {
        memset(mask, 0, cpusetsize);
        memcpy(mask, &kernel_mask, sizeof(struct cpumask));
    }

    SYSCALL_RETURN(ret);
}

int tcgetattr(int fd, struct termios *termios_p)
{
    int ret=0;
    asmlinkage long (*sys_ioctl)(unsigned int fd, unsigned int cmd, unsigned long arg)
        = get_syscall(UK_ioctl);

    /* in glibc tcgetattr.c
       struct __kernel_termios k_termios;
       INLINE_SYSCALL (ioctl, 3, fd, TCGETS, &k_termios);
    */
    PREPARE_KERNEL_CALL;
    ret = sys_ioctl(fd, TCGETS, (unsigned long)termios_p);
    END_KERNEL_CALL;

    SYSCALL_RETURN(ret);
}

int tcflush(int fd, int queue_selector)
{
    //return __ioctl (fd, TCFLSH, queue_selector);
    klog(0,"NOT IMPLEMENT!\n");
    return 0;
}

/* uk_lock / uk_unlock*/

static struct semaphore uk_sem;

struct uk_lock_operations
{
    void (*lock)(void);
    void (*unlock)(void);
};

static struct uk_lock_operations *uk_lock_ops;

void biglock_lock(void)
{
    down(&uk_sem);
}

void biglock_unlock(void)
{
    up(&uk_sem);
}

static struct uk_lock_operations uk_biglock_ops = {
    .lock = biglock_lock,
    .unlock = biglock_unlock,
};

void dummy_lock(void)
{
}

void dummy_unlock(void)
{
}

static struct uk_lock_operations uk_nolock_ops = {
    .lock = dummy_lock,
    .unlock = dummy_unlock,
};


void init_uk_lock(void)
{
    sema_init(&uk_sem, 1);

    if (nr_cpu_ids == 1)
    {
        uk_lock_ops = &uk_nolock_ops;
    }
    else /*  use biglock */
    {
        printk("UK:nr_cpu_ids=%d, use biglock \n",nr_cpu_ids);
        uk_lock_ops = &uk_biglock_ops;
    }
}

void uk_lock(void)
{
    uk_lock_ops->lock();
}

void uk_unlock(void)
{
    uk_lock_ops->unlock();
}


extern struct file *get_unix_file( struct uk_fd *fd );
int uk_sock_error( struct uk_fd *fd )
{
    unsigned int optval = 0;
    struct file *file;
    struct socket *sock;
    struct sock *sk;

    file = get_unix_file(fd);
    if (!file) return optval;

    sock = file->private_data;
    if (!sock) return optval;

    sk = sock->sk;
    if (!sk) return optval;

    if (likely(!sk->sk_err))
        optval = 0;
    else
        optval = xchg(&sk->sk_err, 0);

    if (optval == 0)
        optval = xchg(&sk->sk_err_soft, 0);

    return optval;
}

int check_fin( struct uk_fd *fd )
{
    struct file *file;
    struct socket *sock;
    struct sock *sk;
    struct sk_buff *skb;

    file = get_unix_file(fd);
    if (!file) return 0;

    sock = file->private_data;
    if (!sock) return 0;

    sk = sock->sk;
    if (!sk) return 0;

    if (sk->sk_shutdown & RCV_SHUTDOWN)
    {
        struct tcp_sock *tp = tcp_sk(sk);
        u32 *seq;
        u32 offset;

        seq = &tp->copied_seq;
        skb_queue_walk(&sk->sk_receive_queue, skb)
        {
            offset = *seq - TCP_SKB_CB(skb)->seq;
            if (tcp_hdr(skb)->syn)
                offset--;
            if (offset < skb->len)
                return 0;
            if (tcp_hdr(skb)->fin)
                return 1;
        }
    }
    return 0;
}

int recursive_spin_trylock(recursive_spinlock_t *lock)
{
    spin_lock(&lock->lock);
    if (lock->count <= 0)
    {
        lock->pid = current->pid;
        lock->count = 1;
        spin_unlock(&lock->lock);
        return 1;
    }
    // somebody has the lock
    if (lock->pid == current->pid)
    {
        // it was us! return ok
        lock->count++;
        spin_unlock(&lock->lock);
        return 1;
    }
    spin_unlock(&lock->lock);

    // somebody has the lock and it's not us! return fail
    return 0;
}

void recursive_spin_lock(recursive_spinlock_t *lock)
{
    while (recursive_spin_trylock(lock) == 0)
        /* nothing */;
}

void recursive_spin_unlock(recursive_spinlock_t *lock)
{
    spin_lock(&lock->lock);
    if (--lock->count <= 0)
        lock->count = 0;
    spin_unlock(&lock->lock);
}

void recursive_spin_lock_bh(recursive_spinlock_t *lock)
{
    local_bh_disable();
    preempt_disable();
    recursive_spin_lock(lock);
}

void recursive_spin_unlock_bh(recursive_spinlock_t *lock)
{
    recursive_spin_unlock(lock);
    preempt_enable();
    local_bh_enable();
}

void recursive_spinlock_init(recursive_spinlock_t *lock)
{
    spin_lock_init(&lock->lock);
    lock->pid = -1;
    lock->count = 0;
}
